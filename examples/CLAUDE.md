# CLAUDE.md

Generated by lolek-mcp context-engineering system for web app development.

## STRICT OPERATIONAL RULES

### 1. Structural Decision Framework
- ALWAYS consult DATABASE.md before making any structural decisions
- NEVER create database tables, models, or schemas without referencing current structure
- ALWAYS align component architecture with database relationships
- NEVER implement features that conflict with established data patterns

### 2. File Management Protocol
- ALWAYS edit existing files instead of creating new ones
- NEVER create documentation files unless explicitly requested
- ALWAYS check if similar functionality exists before implementing
- NEVER duplicate code across files
- ALWAYS verify file changes align with DATABASE.md structure

### 3. Component Development
- ALWAYS examine existing components before creating new ones
- ALWAYS follow established naming conventions that match database entities
- NEVER create components without proper TypeScript types derived from database schema
- ALWAYS use existing utility functions and hooks
- NEVER build UI components that don't align with data model

### 4. State Management
- ALWAYS use existing state management patterns that mirror database structure
- NEVER create new state stores without checking existing ones and DATABASE.md
- ALWAYS handle loading and error states for all database operations
- NEVER mutate state directly - follow database transaction patterns
- ALWAYS ensure state shape matches database schema

### 5. API Integration
- ALWAYS handle API errors gracefully with database-aware error messages
- NEVER expose sensitive data in API responses (check DATABASE.md for sensitive fields)
- ALWAYS validate API inputs and outputs against database constraints
- NEVER make API calls without proper error handling
- ALWAYS respect database relationships in API design

### 6. Testing Requirements
- ALWAYS run existing tests before marking complete
- NEVER skip testing for modified functionality
- ALWAYS test error scenarios including database failures
- NEVER assume tests pass without running them
- ALWAYS test database interactions and constraints

### 7. Performance Rules
- ALWAYS consider bundle size impact and database query efficiency
- NEVER load unnecessary dependencies or make inefficient database calls
- ALWAYS optimize images and assets
- NEVER ignore performance warnings or slow database queries
- ALWAYS follow DATABASE.md recommendations for indexing and optimization

### 8. Security Guidelines
- NEVER commit secrets or API keys
- ALWAYS validate user inputs against database constraints
- NEVER trust client-side data
- ALWAYS sanitize user-generated content before database storage
- NEVER expose database structure details in client-side code

## FORBIDDEN ACTIONS
- Creating new files without explicit necessity
- Modifying core configuration without understanding impact
- Adding dependencies without justification
- Implementing features outside current scope
- Bypassing existing error handling patterns
- Making database changes without consulting DATABASE.md
- Creating components that don't align with data model

## REQUIRED ACTIONS BEFORE ANY DEVELOPMENT
1. Read and understand DATABASE.md completely
2. Verify all structural decisions align with database schema
3. Check existing code patterns and database interactions
4. Validate all assumptions against actual database structure
5. Test every change including database operations
6. Ensure UI components reflect database relationships
7. Follow established data access patterns

## WEB APP DEVELOPMENT FOCUS
This is a web application with a structured database. Prioritize:
- Data consistency and integrity (follow DATABASE.md)
- User experience that reflects database relationships
- Responsive design and accessibility
- Performance with efficient database queries
- Security and data protection (respect DATABASE.md constraints)
- Clean, maintainable code structure that mirrors database design

## CRITICAL REQUIREMENT
Before implementing ANY feature, component, or change:
**MUST read DATABASE.md to understand how the change fits into the overall data architecture**

---
*Generated by lolek-mcp context-engineering system*

## Development Commands

### Core Commands
- `npm run dev` - Start development server
- `npm run build` - Build production application  
- `npm start` - Start production server
- `npm test` - Run test suite

### Database Commands
- `npx supabase start` - Start local Supabase instance
- `npx supabase migration new <name>` - Create new migration
- `npx supabase db reset` - Reset database to latest migration
- `./scripts/generate-database-docs.sh` - Generate database documentation

### Linting and Formatting
- `npm run lint` - Run ESLint
- `npm run lint:fix` - Fix ESLint issues automatically
- `npm run format` - Format code with Prettier

## Architecture Overview

### Application Structure
This is a Next.js 15 application with TypeScript, featuring:
- **App Router** with route groups for organization
- **Supabase** for authentication and database
- **Tailwind CSS** with shadcn/ui components
- **Server Actions** for data mutations
- **Middleware** for authentication protection

### Key Directories
- `src/app/` - Next.js App Router pages and layouts
  - `(main)/` - Authenticated user pages
  - `(public)/` - Public pages (landing, login, etc.)
  - `(print)/` - Print-optimized pages
- `src/components/` - Reusable UI components
- `src/lib/` - Utility functions and configurations
- `src/hooks/` - Custom React hooks
- `src/types/` - TypeScript type definitions

### Authentication Flow
1. User visits protected route
2. Middleware checks for valid session
3. If no session, redirect to `/login`
4. After login, redirect to intended page
5. Session managed by Supabase Auth

## Development Patterns

### Component Creation
**ALWAYS check `list-examples` and `get-agent-rules` before creating components**

When creating new components:
1. **First**: Use `list-examples` to find existing component patterns
2. **Then**: Use `get-agent-rules` to understand component usage rules
3. Use TypeScript with proper prop typing
4. Follow existing naming conventions (PascalCase for components)
5. Include proper imports and exports
6. Add error boundaries for complex components
7. Use shadcn/ui components when available (but check agent rules first)

### Database Operations
**ALWAYS check `get-agent-rules` for database constraints before making changes**

- Use Supabase client for browser operations
- Use Supabase server client for server-side operations
- Implement Row Level Security (RLS) policies (preferred)
- Use TypeScript for database types
- Handle errors gracefully with try/catch
- **NEVER create Supabase migrations without checking agent rules first**

### API Routes and Server Actions
**ALWAYS use `list-examples` to find existing patterns before creating new routes**

- Prefer Server Actions over API routes for mutations
- Use proper TypeScript typing for all functions
- Implement proper error handling
- Validate inputs using Zod or similar
- Return consistent response formats

### Styling Guidelines
- Use Tailwind CSS utility classes
- Follow mobile-first responsive design
- Use shadcn/ui components for consistency
- Maintain consistent spacing and typography
- Use CSS variables for theming

## Code Quality Standards

### TypeScript Usage
- Use strict TypeScript configuration
- Avoid `any` types - use proper typing
- Create interfaces for complex objects
- Use generic types where appropriate
- Document complex type definitions

### Error Handling
- Always handle potential errors
- Use try/catch for async operations
- Provide meaningful error messages
- Log errors for debugging
- Show user-friendly error states

### Testing Requirements
- Write unit tests for utility functions
- Create integration tests for critical flows
- Test components with React Testing Library
- Mock external dependencies
- Maintain test coverage above 80%

## Deployment Configuration

### Environment Variables
Required environment variables:
```bash
# Supabase
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

### Build Process
1. Install dependencies: `npm install`
2. Run linting: `npm run lint`
3. Run tests: `npm test`
4. Build application: `npm run build`
5. Start production server: `npm start`

### Vercel Deployment
- Use Node.js 18+ runtime
- Configure environment variables in Vercel dashboard
- Enable edge functions for better performance
- Set up automatic deployments from main branch

## Security Considerations

### Authentication
- Always validate user sessions
- Use Row Level Security (RLS) in Supabase
- Implement proper permission checks
- Never expose sensitive data to client
- Use secure session management

### Data Protection
- Sanitize user inputs
- Use parameterized queries
- Implement rate limiting
- Validate all API inputs
- Use HTTPS in production

## Performance Optimization

### Code Splitting
- Use dynamic imports for large components
- Implement route-based code splitting
- Lazy load non-critical resources
- Use React.lazy() for component loading

### Database Optimization
- Use proper indexes
- Implement efficient queries
- Use connection pooling
- Cache frequent queries
- Monitor query performance

### Asset Optimization
- Optimize images with Next.js Image component
- Use proper image formats (WebP, AVIF)
- Implement lazy loading
- Minify CSS and JavaScript
- Use CDN for static assets

## Troubleshooting

### Common Issues
- **Build failures**: Check TypeScript errors and ESLint warnings
- **Database connection**: Verify environment variables and network access
- **Authentication issues**: Check Supabase configuration and RLS policies
- **Styling problems**: Ensure Tailwind classes are properly imported

### Debug Commands
```bash
# Check environment variables
npm run env:check

# Verify database connection
npm run db:test

# Run type checking
npm run type-check

# Check bundle size
npm run analyze
```

### Logging
- Use structured logging with appropriate levels
- Log errors with full stack traces
- Include request context in logs
- Monitor logs in production
- Set up error tracking (e.g., Sentry)

## Best Practices Summary

### 🔴 ABSOLUTE REQUIREMENTS (NON-NEGOTIABLE)
1. **RUN `get-introduction` FIRST** - This is MANDATORY, not optional
2. **RUN `get-tools` and `list-examples` IMMEDIATELY** - As instructed by introduction
3. **NEVER act outside MCP server** - Everything must come from MCP examples/docs
4. **ALWAYS ask permission for deviations** - Use the exact deviation request format
5. **NO assumptions or improvisation** - If it's not in MCP, ask the user

### Development Practices (AFTER completing mandatory steps)
6. **Follow established workflows** - Use `get-workflow-template` exactly as shown
7. **Use existing patterns only** - Never create new patterns without permission
8. **Respect all agent rules** - No exceptions without user approval
9. **Copy from examples** - Don't write from scratch
10. **Use exact file structures** - As shown in examples
11. **Install only documented packages** - Nothing beyond what's in examples
12. **Follow TypeScript patterns** - Exactly as demonstrated
13. **Implement error handling** - Only as shown in examples
14. **Write tests** - Only using patterns from examples
15. **Use consistent formatting** - As demonstrated in MCP server

---

## 🔑 FINAL CRITICAL REMINDER

### YOU ARE NOT ALLOWED TO:
- ❌ Create ANY code not shown in examples
- ❌ Use ANY approach not documented
- ❌ Make ANY decision not in MCP server
- ❌ Skip the mandatory first steps
- ❌ Proceed without user permission for deviations

### YOU MUST ALWAYS:
- ✅ Run `get-introduction`, then `get-tools`, then `list-examples` FIRST
- ✅ Check MCP server before EVERY action
- ✅ Use EXACT examples as templates
- ✅ Ask permission for ANY deviation
- ✅ Follow this CLAUDE.md without exception

**FAILURE TO COMPLY WITH THESE REQUIREMENTS IS NOT ACCEPTABLE**

*The lolek-mcp server dependency is ABSOLUTE and NON-NEGOTIABLE. No exceptions.*